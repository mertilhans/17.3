# üêö MiniShell Projesi - Kapsamlƒ± Teknik Dok√ºmantasyon ve Kavramsal Analiz

## Giri≈ü: MiniShell Nedir ve Bizden Ne Bekleniyor?

MiniShell, 42 Okulu m√ºfredatƒ±nƒ±n en √∂nemli projelerinden biridir. Temel amacƒ±, UNIX benzeri bir i≈ületim sisteminin temel ta≈üƒ± olan "kabuk" (shell) programƒ±nƒ±n basitle≈ütirilmi≈ü bir versiyonunu C dilinde kodlamaktƒ±r. Bu proje bizden sadece `fork`, `pipe`, `execve` gibi sistem √ßaƒürƒ±larƒ±nƒ± kullanmayƒ± deƒüil, aynƒ± zamanda bir programƒ±n ba≈ütan sona nasƒ±l bir mantƒ±k silsilesiyle √ßalƒ±≈ütƒ±ƒüƒ±nƒ± anlamamƒ±zƒ± bekler.

Kullanƒ±cƒ±dan alƒ±nan basit bir metin girdisinin (`ls -l | grep a > out.txt`) nasƒ±l ayrƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ±nƒ±, yorumlandƒ±ƒüƒ±nƒ±, proseslere b√∂l√ºnd√ºƒü√ºn√º ve i≈ületim sistemi tarafƒ±ndan nasƒ±l √ßalƒ±≈ütƒ±rƒ±ldƒ±ƒüƒ±nƒ± en temel seviyede tecr√ºbe etmemizi saƒülar. Bu s√ºre√ß, modern yazƒ±lƒ±m geli≈ütirmenin temelini olu≈üturan **veri yapƒ±larƒ±, algoritma tasarƒ±mƒ±, bellek y√∂netimi ve proses y√∂netimi** gibi kritik konularda derin bir anlayƒ±≈ü kazandƒ±rƒ±r.

---

## B√∂l√ºm 1: UNIX Proses Y√∂netiminin Temelleri: `fork`, `process` ve `pid`

Minishell'in nasƒ±l √ßalƒ±≈ütƒ±ƒüƒ±nƒ± anlamak i√ßin √∂nce UNIX'in prosesleri nasƒ±l y√∂nettiƒüini bilmemiz gerekir. Bu b√∂l√ºm, projenin temelini olu≈üturan bu √º√ß anahtar kavramƒ± detaylƒ±ca a√ßƒ±klar.

### Proses (Process) Nedir?

Bir **proses**, en basit tanƒ±mƒ±yla, √ßalƒ±≈ümakta olan bir programdƒ±r. Bir programƒ± (`./minishell` gibi) √ßalƒ±≈ütƒ±rdƒ±ƒüƒ±nƒ±zda, i≈ületim sistemi o program i√ßin bellekte bir alan ayƒ±rƒ±r ve programƒ±n komutlarƒ±nƒ± (kodunu) bu alana y√ºkler. Bu "canlƒ±" hale gelmi≈ü programa proses denir. Her prosesin kendine ait kaynaklarƒ± vardƒ±r:

-   **Bellek Alanƒ±**: Kod, global deƒüi≈ükenler ve `stack` (yƒ±ƒüƒ±n) gibi verilerin tutulduƒüu √∂zel bir bellek b√∂lgesi.
-   **Process ID (PID)**: Onu diƒüer proseslerden ayƒ±ran benzersiz bir kimlik numarasƒ±.
-   **File Descriptors (Dosya Tanƒ±mlayƒ±cƒ±larƒ±)**: `STDIN (0)`, `STDOUT (1)`, `STDERR (2)` gibi standart I/O kanallarƒ± ba≈üta olmak √ºzere, a√ßƒ±k dosyalarƒ± temsil eden numaralar.
-   **Durum (State)**: √áalƒ±≈üƒ±yor (running), bekliyor (waiting), uyuyor (sleeping) gibi o anki durumu.

### `fork()` Sistem √áaƒürƒ±sƒ±: Klonlama Sanatƒ±

`fork()`, UNIX'teki en temel ve g√º√ßl√º sistem √ßaƒürƒ±larƒ±ndan biridir. G√∂revi, kendisini √ßaƒüƒ±ran prosesin **birebir aynƒ±sƒ±** olan yeni bir proses (bir klon) olu≈üturmaktƒ±r.

-   **Parent Process (Ana Proses)**: `fork()`'u √ßaƒüƒ±ran orijinal prosestir.
-   **Child Process (√áocuk Proses)**: `fork()` tarafƒ±ndan yeni olu≈üturulan prosestir.

`fork()` √ßaƒürƒ±ldƒ±ƒüƒ±nda i≈ületim sistemi ≈üunlarƒ± yapar:
1.  Parent prosesin bellek alanƒ±nƒ±, dosya tanƒ±mlayƒ±cƒ±larƒ±nƒ± ve diƒüer t√ºm kaynaklarƒ±nƒ± kopyalar.
2.  Yeni bir PID atayarak child prosesi olu≈üturur.
3.  Bu andan itibaren, iki proses de **baƒüƒ±msƒ±z** olarak √ßalƒ±≈ümaya devam eder. Kodun aynƒ± satƒ±rƒ±ndan (`fork()`'un d√∂n√º≈ü√ºnden) yollarƒ±na devam ederler.

**`fork()`'un Geri D√∂n√º≈ü Deƒüeri Neden Kritik?**

`fork()` her iki prosese de bir deƒüer d√∂nd√ºr√ºr, ancak bu deƒüer farklƒ±dƒ±r. Bu fark, hangi prosesin parent, hangisinin child olduƒüunu anlamamƒ±zƒ± saƒülar:

-   **Parent Prosese**: Olu≈üturduƒüu child prosesin PID'sini (pozitif bir sayƒ±) d√∂nd√ºr√ºr.
-   **Child Prosese**: `0` deƒüerini d√∂nd√ºr√ºr.
-   **Hata Durumunda**: `-1` d√∂nd√ºr√ºr.

Minishell'de bu ayrƒ±mƒ± ≈ü√∂yle kullanƒ±rƒ±z:

```c
pid_t pid = fork();

if (pid == -1) {
    // Hata olu≈ütu
}
else if (pid == 0) {
    // Bu kod bloƒüu SADECE child process tarafƒ±ndan √ßalƒ±≈ütƒ±rƒ±lƒ±r.
    // execve() burada √ßaƒürƒ±lƒ±r.
}
else {
    // Bu kod bloƒüu SADECE parent process tarafƒ±ndan √ßalƒ±≈ütƒ±rƒ±lƒ±r.
    // waitpid() ile child'ƒ±n bitmesi burada beklenir.
}
```

### PID ve PPID Nedir?

**PID (Process ID)**: Her prosesin, i≈ületim sistemi tarafƒ±ndan atanan benzersiz bir tam sayƒ± kimliƒüidir. `getpid()` sistem √ßaƒürƒ±sƒ± ile bir proses kendi PID'sini √∂ƒürenebilir. Minishell'de `$$` deƒüi≈ükeni bu deƒüeri temsil eder.

**PPID (Parent Process ID)**: Bir prosesi olu≈üturan ana prosesin PID'sidir. `getppid()` ile √∂ƒürenilir. Her child prosesin bir parent'ƒ± vardƒ±r. Eƒüer bir parent proses, child'ƒ± beklemeden sonlanƒ±rsa, bu child "yetim" (orphan) kalƒ±r ve genellikle sistemin ilk prosesi olan `init` (PID 1) tarafƒ±ndan evlat edinilir.

Bu √º√ß kavram, Minishell'in temel √ßalƒ±≈üma mantƒ±ƒüƒ±nƒ± olu≈üturur: Shell (parent), √ßalƒ±≈ütƒ±racaƒüƒ± her komut i√ßin bir child proses `fork()`'lar. Bu child proses, `execve` ile kendini yeni komutla deƒüi≈ütirir ve i≈üini bitirince sonlanƒ±r. Shell ise bu sƒ±rada `waitpid` ile child'ƒ±n bitmesini bekler.

---

## B√∂l√ºm 2: Proje Mimarisi ve Veri Akƒ±≈üƒ±

Minishell, kullanƒ±cƒ± girdisini adƒ±m adƒ±m i≈üleyen mod√ºler bir "pipeline" (boru hattƒ±) mimarisi √ºzerine kuruludur. Bu, karma≈üƒ±klƒ±ƒüƒ± y√∂netmeyi ve her bir bile≈üenin sorumluluƒüunu net bir ≈üekilde ayƒ±rmayƒ± saƒülar.

### Veri Akƒ±≈ü ≈ûemasƒ±:

**Girdi (char *)**: `readline` ile alƒ±nan ham metin.

```
"echo 'hello $USER' | wc -c > output.txt"
```

**‚û°Ô∏è Mod√ºl 1: LEXER**

√áƒ±ktƒ±: `t_token` yapƒ±larƒ±ndan olu≈üan bir baƒülƒ± liste.

```
[WORD:"echo"] -> [WORD:"'hello $USER'"] -> [PIPE:"|"] -> [WORD:"wc"] -> [WORD:"-c"] -> [REDIR_OUT:">"] -> [WORD:"output.txt"]
```

**‚û°Ô∏è Mod√ºl 2: PARSER**

√áƒ±ktƒ±: `t_parser` yapƒ±larƒ±ndan olu≈üan, pipe ile birbirine baƒülanmƒ±≈ü bir komut listesi.

```
Komut 1 (t_parser):
    argv: ["echo", "'hello $USER'"]
    redirs: NULL
    next: -> Komut 2

Komut 2 (t_parser):
    argv: ["wc", "-c"]
    redirs: [type:REDIR_OUT, filename:"output.txt"]
    next: NULL
```

**‚û°Ô∏è Mod√ºl 3: EXPANDER**

ƒ∞≈ülem: Parser'dan gelen `t_parser` listesindeki `argv` ve `redirs->filename` alanlarƒ±nƒ± i≈üler.

```
Komut 1 (t_parser):
    argv: expand("'hello $USER'") -> ["echo", "hello $USER"] (tek tƒ±rnak y√ºz√ºnden $USER geni≈ületilmez).

Komut 2 (t_parser):
    argv: Deƒüi≈üiklik yok.
    redirs: expand("output.txt") -> [type:REDIR_OUT, filename:"output.txt"]
```

**‚û°Ô∏è Mod√ºl 4: EXECUTOR**

ƒ∞≈ülem: Geni≈ületilmi≈ü komut listesini alƒ±r ve √ßalƒ±≈ütƒ±rƒ±r.

1. `pipe()` olu≈üturulur.
2. Komut 1 i√ßin `fork()`: Child 1, `echo`'yu √ßalƒ±≈ütƒ±rƒ±r, √ßƒ±ktƒ±sƒ±nƒ± pipe'ƒ±n yazma ucuna y√∂nlendirir.
3. Komut 2 i√ßin `fork()`: Child 2, pipe'ƒ±n okuma ucunu stdin olarak ayarlar, `output.txt` dosyasƒ±nƒ± stdout olarak a√ßar ve `wc -c` komutunu √ßalƒ±≈ütƒ±rƒ±r.
4. Parent Process: Her iki child process'in de bitmesini bekler.

---

## B√∂l√ºm 3: Ana D√∂ng√º ve Ba≈ülatma (shell.c)

Shell'in ana iskeleti ve ba≈ülangƒ±√ß yapƒ±landƒ±rmasƒ± bu dosyada yer alƒ±r.

### `main()` Fonksiyonu:

1. **`set_last_exit_status(0)`**: Programƒ±n ba≈ülangƒ±√ß √ßƒ±kƒ±≈ü kodunu 0 olarak ayarlar.

2. **`initialize_shell(env)`**: Shell'i kullanƒ±ma hazƒ±rlar. Bu kritik fonksiyon ≈üunlarƒ± yapar:
   - **`init_env(env)`**: `main` fonksiyonundan gelen `char **env` dizisini, y√∂netimi daha kolay olan `t_env` baƒülƒ± listesine d√∂n√º≈üt√ºr√ºr.
   - **`get_export_list()` ve `init_export_from_env()`**: `export` komutunun kullanacaƒüƒ± ayrƒ± bir `t_export` listesi olu≈üturur ve ba≈ülangƒ±√ßta env listesiyle doldurur.
   - **`init_shell_variables(&env_list)`**: `SHLVL`, `PWD` ve `OLDPWD` gibi temel shell deƒüi≈ükenlerini ayarlar. √ñrneƒüin `SHLVL`'i bir artƒ±rƒ±r.
   - **`setup_interactive_signals()`**: Sinyal y√∂neticilerini interaktif mod i√ßin ayarlar.

3. **`shell_loop(env_list, env)`**: Shell'in ana d√∂ng√ºs√ºn√º ba≈ülatƒ±r.

4. **Temizlik**: D√∂ng√ºden √ßƒ±kƒ±ldƒ±ƒüƒ±nda `rl_clear_history()`, `gb_free_all()` ve `env_gb_free_all()` √ßaƒürƒ±larak t√ºm bellek sƒ±zƒ±ntƒ±larƒ± √∂nlenir.

### `shell_loop(t_env *env_list, char **env)`:

- Sonsuz bir `while(1)` d√∂ng√ºs√º i√ßinde √ßalƒ±≈üƒ±r.
- **`readline()`**: Kullanƒ±cƒ±dan girdi bekler. Girdi satƒ±rƒ± (`line`) alƒ±ndƒ±ƒüƒ±nda, ge√ßmi≈üe (history) eklenir. Ctrl+D basƒ±lƒ±rsa `readline` `NULL` d√∂ner, exit mesajƒ± basƒ±lƒ±r ve d√∂ng√º kƒ±rƒ±lƒ±r.
- **`process_command_line(line, &env_list, env)`**: Alƒ±nan komut satƒ±rƒ±nƒ± i≈ülemek i√ßin ana i≈ülem hattƒ±nƒ± tetikler. Bu fonksiyon, Lexer, Parser ve Executor mod√ºllerini sƒ±rayla √ßaƒüƒ±rƒ±r.

---

## B√∂l√ºm 4: Mod√ºl 1: Lexer (lexer*.c)

**Ama√ß**: Ham metin girdisini, anlamlƒ± birimler olan "token"lara ayƒ±rmak.

### Anahtar Fonksiyonlar ve √áalƒ±≈üma Prensibi

#### `t_token *tokenize_input(char *input)`:

**G√∂revi**: Lexer mod√ºl√ºn√ºn ana giri≈ü noktasƒ±dƒ±r. String'i alƒ±r ve token listesini d√∂nd√ºr√ºr.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`ft_tokenize_control(input)`**: Girdide bariz syntax hatalarƒ± olup olmadƒ±ƒüƒ±nƒ± kontrol eder (√∂rneƒüin, komutun sadece `|` olmasƒ±). Eƒüer hata varsa `NULL` d√∂ner.

2. **`tokenizer_init(input)`**: Girdi string'i ile bir `t_tokenizer` yapƒ±sƒ± olu≈üturur. Bu yapƒ±, string √ºzerinde bir imle√ß gibi davranarak mevcut pozisyonu (`pos`) ve karakteri (`current`) takip eder.

3. **`token_input_2(...)`**: Bir d√∂ng√º i√ßinde `tokenizer_get_next_token`'ƒ± √ßaƒüƒ±rarak t√ºm token'larƒ± alƒ±r ve bunlarƒ± birbirine baƒülayarak listeyi olu≈üturur.

#### `t_token *tokenizer_get_next_token(t_tokenizer *tokenizer)`:

**G√∂revi**: Girdideki bir sonraki token'ƒ± bulup d√∂nd√ºr√ºr.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`ft_skip_space(tokenizer)`**: Anlamsƒ±z bo≈üluklarƒ± atlar.

2. **√ñzel Karakter Kontrol√º**: `>` karakterini kontrol eder. Eƒüer bir sonraki karakter de `>` ise (`lexer_peek`), `TOKEN_REDIR_APPEND` (`>>`) olu≈üturur, deƒüilse `TOKEN_REDIR_OUT` (`>`) olu≈üturur.

3. **`tokenizer_get_next_token_2(tokenizer)`**: `|` ve `<` karakterlerini benzer ≈üekilde i≈üler. `<`'den sonra tekrar `<` geliyorsa `TOKEN_HEREDOC` (`<<`) olu≈üturulur.

4. **Kelime (Word) Tespiti**: Yukarƒ±dakilerden hi√ßbiri deƒüilse, bunun bir kelime olduƒüunu varsayar ve `extract_complex_word(tokenizer)`'ƒ± √ßaƒüƒ±rƒ±r.

#### `char *extract_complex_word(t_tokenizer *tokenizer)`:

**G√∂revi**: Tƒ±rnak i≈üaretlerini (`'` ve `"`) dikkate alarak tek bir token kelimesi √ßƒ±karƒ±r. Lexer'ƒ±n en karma≈üƒ±k mantƒ±ƒüƒ± buradadƒ±r.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`ft_token_data_init(&data)`**: Bir kelimeyi ge√ßici olarak olu≈üturmak i√ßin `t_token_data` yapƒ±sƒ±nƒ± ba≈ülatƒ±r. `data.in_quote` (char) hangi tƒ±rnak i√ßinde olunduƒüunu (`'` veya `"` veya `\0`) tutar.

2. **`while (tokenizer->current && (data.in_quote || (!is_special_char(...) && !is_whitespace(...))))`**: Bu ko≈üul, kelimenin nerede bittiƒüini belirler. Eƒüer bir tƒ±rnak i√ßindeysek (`data.in_quote` doluysa), bo≈üluklar ve √∂zel karakterler de kelimenin bir par√ßasƒ±dƒ±r. Tƒ±rnak i√ßinde deƒüilsek, bo≈üluk veya √∂zel karakter g√∂rd√ºƒü√ºm√ºz an kelime biter.

3. **`process_character(...)`**: D√∂ng√ºn√ºn her adƒ±mƒ±nda bu fonksiyon √ßaƒürƒ±lƒ±r:
   - Gelen karakter tƒ±rnak ise `handle_quote` ile `data.in_quote` durumu g√ºncellenir.
   - T√ºm karakterler `append_char` ile `data.word`'e eklenir.

4. **Hata Kontrol√º**: D√∂ng√º bittiƒüinde `data.in_quote` hala doluysa, bu kapatƒ±lmamƒ±≈ü bir tƒ±rnak vardƒ±r ve hata verilir.

---

## B√∂l√ºm 5: Mod√ºl 2: Parser (parser*.c)

**Ama√ß**: Token listesini, pipe'larla birbirine baƒülanmƒ±≈ü, `t_parser` komut yapƒ±larƒ±na d√∂n√º≈üt√ºrmek.

### Anahtar Fonksiyonlar ve √áalƒ±≈üma Prensibi

#### `t_parser *parse_tokens(t_token *tokens, t_env *env_list)`:

**G√∂revi**: Parser mod√ºl√ºn√ºn ana fonksiyonu.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`ft_all_init(...)`**: `t_all` yapƒ±sƒ±nƒ± olu≈üturur. Bu yapƒ±, hem olu≈üturulan komut listesini (`cmd_list`) hem de environment listesini (`env_list`) bir arada tutarak diƒüer fonksiyonlara kolayca ge√ßilmesini saƒülar.

2. **`ft_syn(tokens)`**: Y√∂nlendirme token'larƒ±ndan sonra bir kelime gelip gelmediƒüi gibi temel syntax kontrollerini yapar.

3. **`while (tokens && tokens->type != TOKEN_EOF)`**: Token listesi bitene kadar d√∂ner. Her d√∂ng√ºde `ft_control_token`'ƒ± √ßaƒüƒ±rarak bir pipe'lƒ±k komut bloƒüunu i≈üler.

#### `t_token *ft_control_token(t_token *tokens, t_all *data)`:

**G√∂revi**: Bir pipe g√∂rene kadar olan token'larƒ± tek bir `t_parser` yapƒ±sƒ±na d√∂n√º≈üt√ºr√ºr.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`init_parser_cmd(&cmd)`**: Yeni, bo≈ü bir `t_parser` yapƒ±sƒ± olu≈üturur. Arg√ºmanlar i√ßin `argv` dizisini ve y√∂nlendirmeler i√ßin `redirs` listesini hazƒ±rlar.

2. **`while (tokens && tokens->type != TOKEN_PIPE && tokens->type != TOKEN_EOF)`**: Pipe g√∂rene kadar `ft_loop`'u √ßaƒüƒ±rarak her token'ƒ± i≈üler.

3. **`finalize_cmd(...)`**: Komutun `argv` dizisini `NULL` ile sonlandƒ±rƒ±r ve olu≈üturulan komutu ana komut listesine (`data->cmd_list`) ekler.

#### `void ft_loop(t_token **tokens, ...)`:

**G√∂revi**: Tek bir token'ƒ± i≈üler ve t√ºr√ºne g√∂re ilgili fonksiyonu √ßaƒüƒ±rƒ±r.

**Mantƒ±ƒüƒ±**:

- **`TOKEN_WORD` ise**: `ft_loop_3`'√º √ßaƒüƒ±rƒ±r. Bu fonksiyon, kelimeyi `expand_with_quotes` ile anƒ±nda geni≈ületir ve `cmd->argv`'a ekler.
- **`TOKEN_REDIR_IN`, `_OUT`, `_APPEND` ise**: `redir_control_state`'i √ßaƒüƒ±rƒ±r. Bu fonksiyon `process_redirection_expansion`'ƒ± tetikler, dosya adƒ±nƒ± geni≈ületir ve `add_redirection` ile `cmd->redirs` listesine ekler.
- **`TOKEN_HEREDOC` ise**: `ft_redir_heredoc` √ßaƒürƒ±lƒ±r. Bu, delimiter'ƒ± i≈üler ve `add_redirection_with_expansion` ile `cmd->redirs` listesine ekler.

---

## B√∂l√ºm 6: Mod√ºl 3: Expander (expander*.c)

**Ama√ß**: Deƒüi≈ükenleri (`$VAR`), √∂zel ifadeleri (`$?`, `$$`) ve tƒ±rnaklarƒ± i≈üleyerek nihai komut arg√ºmanlarƒ±nƒ± olu≈üturmak.

### Anahtar Fonksiyonlar ve √áalƒ±≈üma Prensibi

#### `char *expand_with_quotes(char *str, t_env *env_list)`:

**G√∂revi**: Tƒ±rnak kurallarƒ±nƒ± dikkate alarak bir string'i geni≈ületen ana fonksiyondur.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`init_quote_data(&data)`**: Geni≈ületilmi≈ü sonucu biriktirmek i√ßin bir `t_quote_data` yapƒ±sƒ± olu≈üturur.

2. **`while (str[i])`**: String √ºzerinde karakter karakter ilerler.

3. **`process_quote_loop(...)`** d√∂ng√º i√ßinde √ßaƒürƒ±lƒ±r:
   - Eƒüer karakter `"` veya `'` ise, `handle_quotes` ile tƒ±rnak durumu (`quote_char`) g√ºncellenir. Tƒ±rnak karakterleri sonu√ßtan √ßƒ±karƒ±lƒ±r.
   - Eƒüer karakter `$` ise ve `quote_char != '\''` (tek tƒ±rnak i√ßinde deƒüilsek), `handle_expansion` -> `handle_dollar` √ßaƒürƒ±lƒ±r.
   - Diƒüer t√ºm karakterler `push_char_res` ile doƒürudan sonuca eklenir.

#### `char *handle_dollar(char *str, int *i, t_env *env_list)`:

**G√∂revi**: `$` ile ba≈ülayan bir ifadenin deƒüerini bulur.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`*i`'yi bir artƒ±rarak `$`'ƒ± ge√ßer.

2. **`str[*i]`'nin ne olduƒüuna bakar**:
   - **`?` veya `$`**: `handle_special_vars` √ßaƒürƒ±lƒ±r, bu da `get_last_exit_status()` veya `getpid()`'nin sonucunu string olarak d√∂ner.
   - **Harf veya `_`**: Ge√ßerli bir deƒüi≈üken adƒ±nƒ±n ba≈ülangƒ±cƒ±. `extract_var_name` ile deƒüi≈ükenin tam adƒ±nƒ± (`USER`, `PATH` vb.) okur.

3. **`search_variable`**: Bu isimle √∂nce `env_list`'te (`search_env_variable`), bulunamazsa `export_list`'te (`search_export_variable`) arama yapar.

4. Bulunan deƒüeri (`value`) veya bulunamazsa bo≈ü string'i (`""`) d√∂nd√ºr√ºr.

---

## B√∂l√ºm 7: Mod√ºl 4: Executor (execute*.c)

**Ama√ß**: Hazƒ±rlanmƒ±≈ü komut listesini √ßalƒ±≈ütƒ±rmak, pipe'larƒ± kurmak, I/O y√∂nlendirmelerini yapmak ve prosesleri y√∂netmek.

### Anahtar Fonksiyonlar ve √áalƒ±≈üma Prensibi

#### `int execute_cmds(t_parser *cmd_list, ...)`:

**G√∂revi**: Y√ºr√ºtme s√ºrecini ba≈ülatan ve y√∂neten ana fonksiyondur.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **`data_init(...)`**: `t_exec_data` yapƒ±sƒ±nƒ± ba≈ülatƒ±r. `STDIN` ve `STDOUT`'un `dup()` ile yedeƒüini alƒ±r.

2. **`heredoc_handle(...)`**: **√áok Kritik Adƒ±m**. Diƒüer hi√ßbir ≈üey yapmadan √∂nce, t√ºm heredoc'larƒ± okur. `process_heredocs`'u √ßaƒüƒ±rƒ±r, o da `read_heredoc_with_expand` veya `read_single_heredoc_block` ile kullanƒ±cƒ±dan girdiyi alƒ±r, bir `pipe()`'a yazar ve pipe'ƒ±n okuma fd'sini `cmd->heredoc_fd`'ye kaydeder.

3. **`if (*pid_len == 1 && is_builtin(cmd_list))`**: Eƒüer tek komut varsa ve bu `cd`, `exit` gibi bir built-in ise fork yapmaz. `n_next_or_built`'i √ßaƒüƒ±rƒ±r. Bu fonksiyon I/O y√∂nlendirmelerini yapar (`ft_redir_ctrl`), built-in'i √ßalƒ±≈ütƒ±rƒ±r (`ft_builtin_call`) ve yedeklenmi≈ü `STDIN`/`STDOUT`'u geri y√ºkler (`ft_in_or_out`).

4. **Diƒüer Durumlar**: `setup_parent_execution_signals()` ile ana shell'i sinyallere kar≈üƒ± korur. `ft_data_pids` -> `execute_loop`'u √ßaƒüƒ±rarak fork ve pipe s√ºrecini ba≈ülatƒ±r.

5. **`finish_fd(...)`**: T√ºm i≈ülemler bittikten sonra yedeklenmi≈ü `STDIN`/`STDOUT`'u geri y√ºkler.

#### `void child_process_exec(t_parser *cmd, ...)`:

**G√∂revi**: Bir child process'in yapmasƒ± gereken t√ºm kurulumu yapar.

**Adƒ±m Adƒ±m √áalƒ±≈ümasƒ±**:

1. **Sinyal Ayarƒ±**: `setup_child_signals` ile sinyalleri varsayƒ±lan hale getirir.

2. **Pipe Baƒülantƒ±larƒ±**: `dup2` kullanarak `data->in_fd`'yi `STDIN_FILENO`'ya, `data->pipefd[1]`'i (eƒüer varsa) `STDOUT_FILENO`'ya baƒülar.

3. **Dosya Y√∂nlendirmeleri**: `ft_redir_ctrl` √ßaƒürƒ±lƒ±r. Bu fonksiyon, komutun `redirs` listesindeki `< file`, `> file` gibi y√∂nlendirmeleri `open()` ve `dup2()` kullanarak uygular. Bu, pipe baƒülantƒ±larƒ±ndan sonra √ßalƒ±≈ütƒ±ƒüƒ± i√ßin √∂nceliklidir.

4. **Komutu √áalƒ±≈ütƒ±r**: `ft_exec_start` √ßaƒürƒ±lƒ±r.

---

## B√∂l√ºm 8: Yardƒ±mcƒ± Mod√ºller ve Fonksiyonlar

### Sinyal Y√∂netimi (signal_handler.c, signal_utils.c)

- **`handle_sigint`**: ƒ∞nteraktif modda Ctrl+C basƒ±ldƒ±ƒüƒ±nda tetiklenir. `rl_*` fonksiyonlarƒ± ile readline'a yeni ve bo≈ü bir satƒ±r olduƒüunu bildirir, prompt'u yeniden √ßizer.

- **`handle_sigint_heredoc`**: Heredoc okunurken Ctrl+C basƒ±ldƒ±ƒüƒ±nda tetiklenir. Sadece yeni satƒ±r basar ve `$?`'ƒ± 130 yapar, bu da heredoc okuma d√∂ng√ºs√ºn√º kƒ±rar.

- **`calculate_exit_status`**: `waitpid`'den d√∂nen `status`'u analiz eder. `WIFEXITED` ile normal √ßƒ±kƒ±≈ü kodunu, `WIFSIGNALED` ile sinyal kaynaklƒ± √ßƒ±kƒ±≈ü kodunu (128 + sinyal no) d√∂nd√ºr√ºr.

### Built-in Fonksiyonlarƒ± (builtin_*.c)

- **`built_cd`**: `chdir()` sistem √ßaƒürƒ±sƒ±nƒ± kullanƒ±r. Ba≈üarƒ±lƒ± olursa, `getcwd()` ile yeni `PWD`'yi alƒ±r ve `setenv()` ile hem `PWD` hem de `OLDPWD` ortam deƒüi≈ükenlerini doƒürudan g√ºnceller.

- **`builtin_export`**: Arg√ºmansƒ±z √ßaƒürƒ±ldƒ±ƒüƒ±nda `export_print_all` ile listeyi basar. `export KEY=VALUE` ≈üeklinde √ßaƒürƒ±ldƒ±ƒüƒ±nda, `is_valid_identifier` ile `KEY`'i kontrol eder ve hem `set_export_value` hem de `set_env_value` ile her iki listeyi de g√ºnceller.

- **`builtin_exit`**: `is_numeric_string` ile arg√ºmanƒ±n sayƒ±sal olup olmadƒ±ƒüƒ±nƒ± kontrol eder. `ft_atoi` ile sayƒ±yƒ± alƒ±r ve `exit()` sistem √ßaƒürƒ±sƒ±nƒ± bu deƒüerle yapar.

### Environment ve Bellek Y√∂netimi (env_*.c, gb_*.c)

- **`init_env`**: `main`'den gelen `char **env`'i `ft_strchr` ile `'='` karakterinden b√∂lerek key ve value'yu ayƒ±rƒ±r ve `t_env` listesini olu≈üturur.

- **`env_list_to_array`**: `execve`'nin istediƒüi `char *[]` formatƒ±na `t_env` listesini d√∂n√º≈üt√ºr√ºr. `KEY` ve `VALUE`'yu `'='` ile birle≈ütirerek yeni string'ler olu≈üturur.

- **`gb_malloc`**: `malloc` i√ßin bir "wrapper"dƒ±r. `malloc` sonrasƒ± d√∂nen adresi `gc_safe` aracƒ±lƒ±ƒüƒ±yla k√ºresel bir `t_gb` listesine kaydeder.

- **`gb_free_all`**: Program sonunda bu listeyi dola≈üarak t√ºm belleƒüi serbest bƒ±rakƒ±r ve sƒ±zƒ±ntƒ±larƒ± √∂nler. `env_gb_*` fonksiyonlarƒ± da aynƒ± mantƒ±kla, ancak sadece ortam deƒüi≈ükenleri i√ßin ayrƒ± bir liste √ºzerinde √ßalƒ±≈üƒ±r.
